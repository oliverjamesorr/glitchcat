<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Shadow Lantern — Single File Game</title>
<style>
  :root{--bg:#0b0b12;--light:#ffd77a;--accent:#ffb86b}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#05050a 0%, #0e0e17 100%);color:#fff;font-family:Consolas,monaco,monospace}
  #game-wrap{display:flex;gap:16px;padding:18px;align-items:flex-start}
  canvas{background:transparent;border-radius:8px;box-shadow:0 8px 30px rgba(0,0,0,.7)}
  #ui{width:320px}
  .panel{background:rgba(255,255,255,0.03);padding:12px;border-radius:8px;margin-bottom:12px}
  h1{font-size:20px;margin:0 0 8px}
  .row{display:flex;align-items:center;gap:8px}
  .stat{font-size:14px}
  #flame-bar{height:18px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;margin-top:8px}
  #flame-level{height:100%;width:100%;background:linear-gradient(90deg,var(--light),var(--accent));transform-origin:left}
  button{background:rgba(255,255,255,0.04);color:#fff;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:6px;cursor:pointer}
  button:active{transform:translateY(1px)}
  .center{display:flex;align-items:center;justify-content:center}
  small{opacity:.7}
  .hint{font-size:13px;opacity:.9}
  #footer{font-size:12px;opacity:.8;margin-top:6px}
</style>
</head>
<body>
<div id="game-wrap">
  <div>
    <canvas id="game" width="900" height="600"></canvas>
    <div class="center" style="margin-top:8px">
      <button id="restartBtn">Restart</button>
      <button id="muteBtn">Mute</button>
      <button id="toggleDebug">Toggle Debug</button>
    </div>
  </div>
  <div id="ui">
    <div class="panel">
      <h1>Shadow Lantern</h1>
      <div class="row"><div class="stat">Score: <span id="score">0</span></div></div>
      <div class="row" style="margin-top:8px"><div class="stat">Level: <span id="level">1</span></div></div>
      <div style="margin-top:10px">
        <div class="hint">Flame</div>
        <div id="flame-bar"><div id="flame-level"></div></div>
        <small>Collect glowing embers to refill your flame.</small>
      </div>
    </div>

    <div class="panel">
      <div class="hint">Controls</div>
      <ul style="margin:8px 0 0 18px">
        <li>Arrows / A D — Move</li>
        <li>Space / W — Jump</li>
        <li>Mouse — Aim light</li>
        <li>Click — Toggle light intensity</li>
      </ul>
    </div>

    <div class="panel">
      <div class="hint">Goal</div>
      <p style="margin:6px 0 0">Reveal the hidden platforms with your light, collect embers, solve simple shadow puzzles, avoid shadowlings in the dark, and reach the golden lantern.</p>
    </div>

    <div class="panel">
      <div class="hint">Status</div>
      <div id="message">Playing...</div>
      <div id="footer">Made as a single-file prototype. Ask to expand levels, add music or skins.</div>
    </div>
  </div>
</div>

<script>
// ----- Shadow Lantern: Single-file 2D prototype -----
// Controls & design: mobile-friendly-ish but optimized for desktop
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width; const H = canvas.height;

  // UI refs
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const flameLevelEl = document.getElementById('flame-level');
  const messageEl = document.getElementById('message');
  const restartBtn = document.getElementById('restartBtn');
  const muteBtn = document.getElementById('muteBtn');
  const toggleDebug = document.getElementById('toggleDebug');

  let debug=false, muted=false;
  muteBtn.onclick = () => { muted=!muted; muteBtn.textContent=muted?'Unmute':'Mute'; };
  toggleDebug.onclick = ()=>{ debug=!debug };

  restartBtn.onclick = ()=>{ initGame(); }

  // Game state
  const GRAV = 0.9;
  let keys = {};
  let mouse = {x: W/2, y: H/2, down:false};
  let state = {};

  // Levels: simple map with platforms and embers, goal
  const levels = [
    // Level 1: tutorial
    {
      platforms:[ {x:0,y:540,w:900,h:60}, {x:220,y:420,w:140,h:20}, {x:420,y:330,w:120,h:20}, {x:620,y:240,w:140,h:20} ],
      embers:[ {x:250,y:390},{x:460,y:300},{x:670,y:210} ],
      goal:{x:760,y:180,w:40,h:40}
    },
    // Level 2: hidden platform puzzle (platforms hidden until lit)
    {
      platforms:[ {x:0,y:540,w:900,h:60}, {x:140,y:420,w:100,h:20,hidden:true}, {x:260,y:380,w:90,h:20,hidden:true}, {x:400,y:330,w:130,h:20,hidden:true}, {x:680,y:260,w:120,h:20,hidden:true} ],
      embers:[ {x:150,y:380},{x:420,y:300},{x:730,y:230} ],
      goal:{x:740,y:220,w:40,h:40}
    },
    // Level 3: shadowlings (enemies) appear when out of light
    {
      platforms:[ {x:0,y:540,w:900,h:60}, {x:180,y:460,w:100,h:20}, {x:340,y:420,w:140,h:20}, {x:520,y:360,w:120,h:20}, {x:720,y:300,w:120,h:20} ],
      embers:[ {x:200,y:430},{x:370,y:390},{x:560,y:330},{x:740,y:270} ],
      goal:{x:760,y:250,w:40,h:40},
      enemies:[ {x:500,y:520},{x:100,y:520} ]
    }
  ];

  // Player
  function makePlayer(){
    return {
      x:60,y:480,w:22,h:30,vx:0,vy:0,onGround:false,
      speed:3.2,jump:13
    }
  }

  // init
  function initGame(){
    state.level = 0;
    state.score = 0;
    state.player = makePlayer();
    state.flame = 100; // percent
    state.lightOn = true;
    state.lightRadius = 250; // pixels
    state.lightIntensity = 1; // multiplier
    state.msg = 'Playing...';
    state.spawnTimer = 0;
    state.enemies = [];
    loadLevel(state.level);
  }

  function loadLevel(i){
    const lvl = levels[i];
    state.map = JSON.parse(JSON.stringify(lvl)); // clone
    state.startTime = Date.now();
    levelEl.textContent = i+1;
    state.player.x = 60; state.player.y = 480; state.player.vx=0; state.player.vy=0;
    state.flame = 100;
  }

  // Input
  window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()]=true; if(['w','arrowup',' '].includes(e.key.toLowerCase())) e.preventDefault(); });
  window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false });
  canvas.addEventListener('mousemove', e=>{ const r=canvas.getBoundingClientRect(); mouse.x = e.clientX - r.left; mouse.y = e.clientY - r.top; });
  canvas.addEventListener('mousedown', e=>{ mouse.down=true; state.lightIntensity = state.lightIntensity===1?1.8:1; });
  window.addEventListener('mouseup', e=>{ mouse.down=false });

  // simple audio (tones)
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let actx = null;
  function playTone(freq, dur=0.12){ if(muted) return; try{ if(!actx) actx = new AudioCtx(); const o = actx.createOscillator(); const g = actx.createGain(); o.connect(g); g.connect(actx.destination); o.type='sine'; o.frequency.value=freq; g.gain.value=0.05; o.start(); g.gain.exponentialRampToValueAtTime(0.0001, actx.currentTime+dur); o.stop(actx.currentTime+dur+0.02);}catch(e){} }

  // collisions
  function aabb(a,b){ return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h); }

  // game loop
  let last = 0;
  function update(dt){
    const p = state.player;
    // input
    const left = keys['arrowleft'] || keys['a'];
    const right = keys['arrowright'] || keys['d'];
    const up = keys['arrowup'] || keys['w'] || keys[' '];
    if(left) p.vx = Math.max(p.vx - 0.8, -p.speed);
    if(right) p.vx = Math.min(p.vx + 0.8, p.speed);
    if(!left && !right) p.vx *= 0.8;

    // jump
    if(up && p.onGround){ p.vy = -p.jump; p.onGround=false; playTone(660,0.08); }

    // physics
    p.vy += GRAV*0.45;
    p.x += p.vx;
    p.y += p.vy;

    // world collisions
    p.onGround = false;
    for(const plat of state.map.platforms){
      // treat hidden platforms same for physics (solid) even if hidden
      const env = {x:plat.x,y:plat.y,w:plat.w,h:plat.h};
      if(aabb(p,env)){
        // simple separation
        if(p.vy > 0 && p.y + p.h - p.vy <= env.y + 4){ // landed on top
          p.y = env.y - p.h; p.vy = 0; p.onGround = true;
        } else if(p.vy < 0 && p.y >= env.y + env.h - 4){ // hit head
          p.y = env.y + env.h; p.vy = 0;
        } else {
          // horizontal push
          if(p.x < env.x) p.x = env.x - p.w; else p.x = env.x + env.w;
          p.vx = 0;
        }
      }
    }

    // keep inside
    if(p.x < 0) { p.x = 0; p.vx = 0 }
    if(p.x + p.w > W) { p.x = W - p.w; p.vx = 0 }
    if(p.y > H){ // fell
      state.msg = 'You fell! Restarting level...'; playTone(120,0.25); loadLevel(state.level);
    }

    // light mechanics: consume flame when light on
    if(state.lightOn){
      // flame drains faster if intensity high
      state.flame -= 0.02 * (state.lightIntensity);
      if(state.flame < 0) state.flame = 0;
    } else {
      // small natural drain
      state.flame -= 0.003;
    }
    if(state.flame <= 0){
      state.lightOn = false; state.msg = 'Your flame has gone out! Collect ember to refuel.'; playTone(140,0.2);
    }

    // collect embers
    for(let i=state.map.embers.length-1;i>=0;i--){
      const e = state.map.embers[i];
      if(Math.hypot((p.x+p.w/2)-e.x, (p.y+p.h/2)-e.y) < 28){
        state.map.embers.splice(i,1); state.score += 100; state.flame = Math.min(100, state.flame + 34); playTone(880,0.08);
      }
    }

    // goal
    if(aabb(p, state.map.goal)){
      state.score += 500; playTone(980,0.18); state.level++;
      if(state.level >= levels.length){ state.msg='You win! All levels completed.'; state.level = levels.length-1; }
      else { state.msg='Level cleared! Loading next...'; loadLevel(state.level); }
    }

    // enemies (shadowlings)
    state.enemies = state.enemies.filter(e=>e.alive!==false);
    if(state.map.enemies && state.enemies.length < (state.map.enemies.length||0)){
      // spawn gradually
      state.spawnTimer += dt;
      if(state.spawnTimer > 1200){
        const spec = state.map.enemies[state.enemies.length%state.map.enemies.length];
        state.enemies.push({x:spec.x,y:spec.y,vx: (Math.random()>0.5?1:-1)*1.0}); state.spawnTimer=0;
      }
    }
    for(const en of state.enemies){
      // simple patrol
      en.x += en.vx;
      if(en.x < 10 || en.x > W-10) en.vx *= -1;
      // if player is in light cone, enemy takes damage / vanishes
      if(isPointLit(en.x+8, en.y+8)){
        en.alive = false; state.score += 75; playTone(520,0.05);
      }
      // collision with player when enemy is in dark -> hurt
      if(aabb({x:en.x,y:en.y,w:16,h:16}, p) && !isPointLit(p.x+p.w/2,p.y+p.h/2)){
        // player hurt
        state.score = Math.max(0, state.score - 100); state.flame = Math.max(0, state.flame - 30); playTone(160,0.25);
        // push back
        p.vx = -en.vx*3; p.vy = -6;
      }
    }

    // UI updates
    scoreEl.textContent = state.score;
    flameLevelEl.style.width = Math.max(0, state.flame) + '%';
    messageEl.textContent = state.msg || 'Playing...';
  }

  // rendering
  function render(){
    ctx.clearRect(0,0,W,H);

    // background
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#070712'); g.addColorStop(1,'#0b0b12');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // draw platforms (some hidden until lit)
    // first, render normal world as dark silhouettes
    for(const plat of state.map.platforms){
      ctx.save();
      if(plat.hidden){
        // dark, slightly visible silhouette
        ctx.fillStyle = 'rgba(18,18,22,0.95)';
      } else {
        ctx.fillStyle = 'rgba(40,40,48,0.95)';
      }
      ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
      ctx.restore();
    }

    // embers (glow)
    for(const e of state.map.embers){
      drawGlow(e.x, e.y, 12, 'rgba(255,200,120,0.9)');
      // ember sprite (pixel-style)
      ctx.fillStyle = '#fff2d1'; ctx.fillRect(e.x-4,e.y-4,3,3); ctx.fillRect(e.x,e.y-4,3,3); ctx.fillRect(e.x-1,e.y-1,4,4);
    }

    // goal (golden lantern)
    const ggoal = state.map.goal;
    drawGlow(ggoal.x + ggoal.w/2, ggoal.y + ggoal.h/2, 18, 'rgba(255,220,120,0.75)');
    ctx.fillStyle = '#ffd980'; ctx.fillRect(ggoal.x, ggoal.y, ggoal.w, ggoal.h);
    ctx.fillStyle = '#b36b00'; ctx.fillRect(ggoal.x+8, ggoal.y+8, ggoal.w-16, ggoal.h-16);

    // enemies (draw as shadows)
    for(const en of state.enemies){
      if(!en.alive) continue;
      // enemy is dark blob normally, but when lit, draw outline
      if(isPointLit(en.x+8,en.y+8)){
        // hurt effect
        drawGlow(en.x+8,en.y+8,20,'rgba(255,90,90,0.6)');
        ctx.fillStyle = '#ffffff'; ctx.fillRect(en.x,en.y,16,16);
      } else {
        ctx.fillStyle = 'rgba(5,5,7,0.95)'; ctx.fillRect(en.x,en.y,16,16);
      }
    }

    // player (simple pixel cat/lantern spirit)
    const p = state.player;
    // draw body
    ctx.save();
    // lantern glow at center
    drawGlow(p.x+p.w/2, p.y+p.h/2, 12, 'rgba(255,210,120,0.6)');
    // pixel art: body
    ctx.fillStyle = '#ffd78c'; ctx.fillRect(p.x, p.y, p.w, p.h);
    // eyes
    ctx.fillStyle = '#2b2b2b'; ctx.fillRect(p.x+4, p.y+6, 3,3); ctx.fillRect(p.x+14, p.y+6, 3,3);
    // little flame on head
    ctx.fillStyle = '#ffefc8'; ctx.fillRect(p.x+9, p.y-6, 5,6);
    ctx.restore();

    // LIGHT MASK (darkness with a hole for the light cone)
    // We'll draw a fullscreen dark layer, then cut out the lit area using composite operation
    ctx.save();
    ctx.fillStyle = 'rgba(2,2,4,0.96)';
    ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'destination-out';

    // compute light cone center and radius
    const lx = p.x + p.w/2;
    const ly = p.y + p.h/2;
    const mx = mouse.x; const my = mouse.y;
    const ang = Math.atan2(my-ly, mx-lx);

    // soft cone as multiple overlapping radial gradients along beam
    const rBase = state.lightRadius * (state.lightIntensity);
    for(let i=0;i<6;i++){
      const t = i/5;
      const cx = lx + Math.cos(ang) * rBase * t;
      const cy = ly + Math.sin(ang) * rBase * t;
      const rad = rBase * (0.16 + 0.84*(1 - t*0.7));
      const g2 = ctx.createRadialGradient(cx,cy,rad*0.12,cx,cy,rad);
      const alpha = state.lightOn ? (0.65*(1 - t*0.5)) : 0.05;
      g2.addColorStop(0, `rgba(255,230,160,${alpha})`);
      g2.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g2;
      ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.fill();
    }

    // cut a stronger center cone
    const coneLen = rBase;
    const coneW = Math.PI/7;
    // draw triangular-ish cone by clipping many arcs
    ctx.beginPath();
    for(let t=0;t<=1;t+=0.05){
      const rr = coneLen * t;
      const ax = lx + Math.cos(ang-coneW) * rr;
      const ay = ly + Math.sin(ang-coneW) * rr;
      ctx.lineTo(ax,ay);
    }
    for(let t=1;t>=0;t-=0.05){
      const rr = coneLen * t;
      const bx = lx + Math.cos(ang+coneW) * rr;
      const by = ly + Math.sin(ang+coneW) * rr;
      ctx.lineTo(bx,by);
    }
    ctx.closePath(); ctx.fill();

    // restore composite
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();

    // reveal hidden platforms if lit
    for(const plat of state.map.platforms){
      if(plat.hidden){
        // check a few sample points on platform for lit
        const samples = [{x:plat.x+10,y:plat.y+5},{x:plat.x+plat.w-10,y:plat.y+5},{x:plat.x+plat.w/2,y:plat.y+5}];
        for(const s of samples){ if(isPointLit(s.x, s.y)){ plat.hidden=false; break; } }
      }
    }

    // debug info
    if(debug){
      ctx.fillStyle='white'; ctx.font='12px monospace'; ctx.fillText('DEBUG ON', 8, 16);
      ctx.fillText('player: '+Math.round(p.x)+','+Math.round(p.y),8,32);
      ctx.fillText('flame: '+Math.round(state.flame),8,48);
    }
  }

  // helper: check if a point is lit by the current light cone
  function isPointLit(px, py){
    const p = state.player; const lx = p.x+p.w/2, ly=p.y+p.h/2;
    const dx = px - lx, dy = py - ly; const d = Math.hypot(dx,dy);
    if(d > state.lightRadius * state.lightIntensity) return false;
    const ang = Math.atan2(mouse.y-ly, mouse.x-lx);
    const pang = Math.atan2(dy,dx);
    let diff = Math.abs(((pang - ang + Math.PI) % (Math.PI*2)) - Math.PI);
    // within 40 deg cone
    return diff < (Math.PI/7) && state.lightOn && state.flame>0;
  }

  // glow helper
  function drawGlow(x,y,size,color){
    const g = ctx.createRadialGradient(x,y,0,x,y,size);
    g.addColorStop(0, color);
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,size,0,Math.PI*2); ctx.fill();
  }

  // main loop
  function loop(ts){
    if(!last) last=ts; const dt = ts-last; last=ts;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  initGame();
  requestAnimationFrame(loop);

  // expose some debug features via window for quick edits
  window.SL = {state, levels, ctx, canvas};

})();
</script>
</body>
</html>

